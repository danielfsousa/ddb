package commitlog

import (
	"bufio"
	"encoding/binary"
	"errors"
	"io"
	"os"
)

// ========== Hint File Format ===========
// +-----------+----------------+--------+
// | keyLenght | recordPosition | key    |
// +-----------+----------------+--------+
// | 8 bytes   | 8 bytes        | ?      |
// +-----------+----------------+--------+

type hint struct {
	file *os.File
	buf  *bufio.Writer
	size uint64
}

const (
	keyLenSize     = 8
	recPosSize     = 8
	hintHeaderSize = keyLenSize + recPosSize
)

func newHint(f *os.File) (*hint, error) {
	fi, err := os.Stat(f.Name())
	if err != nil {
		return nil, err
	}
	return &hint{
		file: f,
		size: uint64(fi.Size()),
		buf:  bufio.NewWriter(f),
	}, nil
}

// Name returns the hint's file path.
func (h *hint) Name() string {
	return h.file.Name()
}

func (h *hint) Write(key string, pos uint64) error {
	keyLen := uint64(len(key))

	// serialize header
	metadata := [hintHeaderSize]byte{}
	binary.BigEndian.PutUint64(metadata[:keyLenSize], keyLen)
	binary.BigEndian.PutUint64(metadata[keyLenSize:], pos)

	// write header
	_, err := h.buf.Write(metadata[:])
	if err != nil {
		return err
	}

	// write key
	_, err = h.buf.WriteString(key)
	if err != nil {
		return err
	}

	h.size += hintHeaderSize + keyLen
	return nil
}

func (h *hint) Sync() error {
	if err := h.buf.Flush(); err != nil {
		return err
	}
	return h.file.Sync()
}

func (h *hint) Close() error {
	if err := h.buf.Flush(); err != nil {
		return err
	}
	return h.file.Close()
}

func (h *hint) Scanner() (*hintScanner, error) {
	f, err := os.Open(h.file.Name())
	if err != nil {
		return nil, err
	}
	return &hintScanner{
		reader: f,
	}, nil
}

type hintScanner struct {
	reader io.Reader
	key    string
	pos    uint64
	err    error
}

// Scan advances the scanner to the next record.
func (s *hintScanner) Scan() bool {
	var header [hintHeaderSize]byte
	if _, s.err = io.ReadFull(s.reader, header[:]); s.err != nil {
		if errors.Is(s.err, io.EOF) {
			s.err = nil
		}
		return false
	}

	keyLen := binary.BigEndian.Uint64(header[:keyLenSize])
	s.pos = binary.BigEndian.Uint64(header[keyLenSize:])

	key := make([]byte, keyLen)
	if _, s.err = io.ReadFull(s.reader, key); s.err != nil {
		return false
	}

	s.key = string(key)
	return true
}

// Next returns the most recent key generated by a call to Scan.
func (s *hintScanner) Next() (key string, pos uint64) {
	return s.key, s.pos
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s *hintScanner) Err() error {
	return s.err
}
